# 동시성2
##### 클라이언트/서버 예제에서는 단일 스레드로 동작하던 서버를 다중 스레드로 변경하는 것과 코드를 깨끗하게 변경하는 내용을 다룬다.

## 클라이언트/서버 예제
일반적으로 애플리케이션에서 많은 시간을 보내는 가능성은 크게 2가지이다.
 - I/O : 소켓 사용, 데이터베이스 연결, 가상 메모리 스와핑 기다리기 등
 - 프로세서 : 수치 계산, 정규 표현식 처리, 가비지 컬렉션 등

일반적으로 프로그램이 프로세서 연산에 많은 시간을 보낸다면, 하드웨어를 추가하여 성능을 높이는 방식이 적합하다.
프로세서 연산에 시간을 보내는 프로그램은 스레드를 늘린다고 해결할 수 있는 문제가 아니다.
하지만 프로그램이 주로 I/O 연산에 시간을 보낸다면 동시성이 성능을 높여 줄 수 있다.

단일스레드 시스템에서 다중 스레드 시스템으로 변환하고, 성능을 높이기 위해서는 다음과 같은 방법을 사용해야한다.
 - 프로그램이 I/O에 많은 시간을 보내야 한다.
 - 관련된 코드(스레드)를 분리시켜 여러개의 클래스로 분리(스레드를 관리하는 코드는 스레드만 관리하도록)해 단일 책임 원칙을 지켜야 한다.


## 가능한 실행경로
```
 public class IdGenerator{
  private int lastIdUsed;
  
  public int incrementValue(){
    return ++lastIdUsed;
  }
 }
```
만약 lastIdUsed 초깃값을 93으로 가정할때 가능한 결과는 다음과 같다
  - case1) A 스레드는 94을 받는다. B 스레드는 95를 받는다. lastIdUsed는 95가 된다.
  - case2) A 스레드는 95를 받는다. B 스레드는 94을 받는다. lastIdUsed는 95가 된다.
  - case3) A 스레드는 94을 받는다. B 스레드는 94을 받는다. lastIdUsed는 94이 된다.
어이없게도 마지막 결과도 가능하다.

### 경로 수
위 코드중 return ++lastIdUsed 라는 코드 한줄은 바이트 코드 명령 8개에 해당한다
만약 두 스레드가 명령 8개를 뒤섞어 실행할 경우 경우의 수는 엄청 많아지게 된다

### 심층 분석
#### 원자적 연산(atomic operation)이란?
중단이 불가능한 연산을 원자적 연산이라고 정의한다. 다음 예제를 살펴보자
```
public class Example{
 int lastId;
 
 public void resetId(){
   lastId = 0;  //원자적 연산 부분
 }
 
 public void getNextId(){
   ++lastId;    //전처리 증가 연산 부분
 }
}
```
표시한 lastId에 0을 할당하는 연산은 원자적이다.
자바 메모리 모델에 의하면 32비트 메모리에 값을 할당하는 연산은 중단이 불가능하기 때문이다.
하지만 만약 lastId를 int에서 long으로 바꾼다면 경우에따라 어떤 프로세서는 원자적 연산으로 처리할지도 모르지만
64비트 값을 할당하는 연산은 32비트 값을 할당하는 연산 두개로 나눠진다. 즉 첫 32비트 값을 할당한 후 둘째 32비트 값을 할당하기 직전에 
다른 스레드가 끼어들어 두 32비트 값중 하나를 변경할수 있다는 의미이다.

전처리 증가 연산인 ++lastId는 중단이 가능하기에 원자적연산이다.
예를들어 lastId가 42였다고 가정했을시,
첫째 스레드가 실행되는 도중 중단되고 둘째 스레드가 끼어들어 먼저 명령을 실행하여 43을 얻어갔다.
이제 첫째 스레드가 중단했던 실행을 재개한후 1을 더해 43을 얻은후 결과를 저장한다. 첫째 스레드 역시 43을 가져간다.
둘째 스레드가 증가한 값은 잃어버린다. 둘째 스레드가 첫째 스레드를 중단한 후 다시 실행된 첫째 슬드가 둘째 스레드의 작업을 덮어썼기 때문이다.
getNextId() 메서드를 synchronized(동기화 : 현재 데이터를 사용하고 있는 해당 스레드를 제외하고 나머지 스레드들은 데이터에 접근 할 수 없도록 막는 개념)로 
선언하면 문제는 해결되게 된다.

스레드가 서로의 작업을 덮어쓰는 과정을 이해하기 위해서는 어떤 연산이 안전한지 못한지를 파악할 수 있도록 메모리 모델을 이해하고 있어야한다.
즉, 아래의 3가지를 이해해야 한다.

 - 공유 객체/값이 있는 곳
 - 동시 읽기/수정 문제를 일으킬 소지가 있는 코드
 - 동시성 문제를 방지하는 법

## 라이브러리를 이해하라

### Executor 프레임워크
 - 스레드 풀링으로 정교한 실행을 지원한다.
 - 코드가 깔끔해지고 이해하기 쉬워지며, 크기가 작아진다.
 - 스레드 풀 크기를 자동으로 조정하며, 재사용할 수 있다.

### 스레드를 차단하지 않는 방법(non blocking)
 - 최신 프로세서는 blocking 하지 않고 안정적으로 값을 갱신한다.
 - 현대 프로세서는 [CAS(Compare and Swap)](https://chickenpaella.tistory.com/97)을 지원한다.

