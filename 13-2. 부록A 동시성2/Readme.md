# 동시성2
##### 클라이언트/서버 예제에서는 단일 스레드로 동작하던 서버를 다중 스레드로 변경하는 것과 코드를 깨끗하게 변경하는 내용을 다룬다.

## 클라이언트/서버 예제
일반적으로 애플리케이션에서 많은 시간을 보내는 가능성은 크게 2가지이다.
 - I/O : 소켓 사용, 데이터베이스 연결, 가상 메모리 스와핑 기다리기 등
 - 프로세서 : 수치 계산, 정규 표현식 처리, 가비지 컬렉션 등

일반적으로 프로그램이 프로세서 연산에 많은 시간을 보낸다면, 하드웨어를 추가하여 성능을 높이는 방식이 적합하다.
프로세서 연산에 시간을 보내는 프로그램은 스레드를 늘린다고 해결할 수 있는 문제가 아니다.
하지만 프로그램이 주로 I/O 연산에 시간을 보낸다면 동시성이 성능을 높여 줄 수 있다.

단일스레드 시스템에서 다중 스레드 시스템으로 변환하고, 성능을 높이기 위해서는 다음과 같은 방법을 사용해야한다.
 - 프로그램이 I/O에 많은 시간을 보내야 한다.
 - 관련된 코드(스레드)를 분리시켜 여러개의 클래스로 분리(스레드를 관리하는 코드는 스레드만 관리하도록)해 단일 책임 원칙을 지켜야 한다.


## 가능한 실행경로
```
 public class IdGenerator{
  private int lastIdUsed;
  
  public int incrementValue(){
    return ++lastIdUsed;
  }
 }
```
만약 lastIdUsed 초깃값을 93으로 가정할때 가능한 결과는 다음과 같다
  - case1) A 스레드는 94을 받는다. B 스레드는 95를 받는다. lastIdUsed는 95가 된다.
  - case2) A 스레드는 95를 받는다. B 스레드는 94을 받는다. lastIdUsed는 95가 된다.
  - case3) A 스레드는 94을 받는다. B 스레드는 94을 받는다. lastIdUsed는 94이 된다.
어이없게도 마지막 결과도 가능하다.

### 경로 수
위 코드중 return ++lastIdUsed 라는 코드 한줄은 바이트 코드 명령 8개에 해당한다
만약 두 스레드가 명령 8개를 뒤섞어 실행할 경우 경우의 수는 엄청 많아지게 된다

### 심층 분석
#### 원자적 연산(atomic operation)이란?
중단이 불가능한 연산을 원자적 연산이라고 정의한다. 다음 예제를 살펴보자
```
public class Example{
 int lastId;
 
 public void resetId(){
   lastId = 0;  //원자적 연산 부분
 }
 
 public void getNextId(){
   ++lastId;    //전처리 증가 연산 부분
 }
}
```
표시한 lastId에 0을 할당하는 연산은 원자적이다.
자바 메모리 모델에 의하면 32비트 메모리에 값을 할당하는 연산은 중단이 불가능하기 때문이다.
하지만 만약 lastId를 int에서 long으로 바꾼다면 경우에따라 어떤 프로세서는 원자적 연산으로 처리할지도 모르지만
64비트 값을 할당하는 연산은 32비트 값을 할당하는 연산 두개로 나눠진다. 즉 첫 32비트 값을 할당한 후 둘째 32비트 값을 할당하기 직전에 
다른 스레드가 끼어들어 두 32비트 값중 하나를 변경할수 있다는 의미이다.

전처리 증가 연산인 ++lastId는 중단이 가능하기에 원자적연산이다.
예를들어 lastId가 42였다고 가정했을시,
첫째 스레드가 실행되는 도중 중단되고 둘째 스레드가 끼어들어 먼저 명령을 실행하여 43을 얻어갔다.
이제 첫째 스레드가 중단했던 실행을 재개한후 1을 더해 43을 얻은후 결과를 저장한다. 첫째 스레드 역시 43을 가져간다.
둘째 스레드가 증가한 값은 잃어버린다. 둘째 스레드가 첫째 스레드를 중단한 후 다시 실행된 첫째 슬드가 둘째 스레드의 작업을 덮어썼기 때문이다.
getNextId() 메서드를 synchronized(동기화 : 현재 데이터를 사용하고 있는 해당 스레드를 제외하고 나머지 스레드들은 데이터에 접근 할 수 없도록 막는 개념)로 
선언하면 문제는 해결되게 된다.

스레드가 서로의 작업을 덮어쓰는 과정을 이해하기 위해서는 어떤 연산이 안전한지 못한지를 파악할 수 있도록 메모리 모델을 이해하고 있어야한다.
즉, 아래의 3가지를 이해해야 한다.

 - 공유 객체/값이 있는 곳
 - 동시 읽기/수정 문제를 일으킬 소지가 있는 코드
 - 동시성 문제를 방지하는 법

## 라이브러리를 이해하라

### Executor 프레임워크
 - 스레드 풀링으로 정교한 실행을 지원한다.
 - 코드가 깔끔해지고 이해하기 쉬워지며, 크기가 작아진다.
 - 스레드 풀 크기를 자동으로 조정하며, 재사용할 수 있다.

### 스레드를 차단하지 않는 방법(non blocking)
 - 최신 프로세서는 차단 하지 않고도 안정적으로 값을 갱신한다.(synchronized의 경우 둘째 스레드가 같은 값을 갱신하지 않더라도 무조건 락부터 건다.)
 - 현대 프로세서는 [CAS(Compare and Swap)](https://chickenpaella.tistory.com/97)을 지원한다.

### 다중 스레드 환경에서 안전하지 않은 클래스
 - SimpleDateFormat
 - 데이터베이스 연결
 - java.util 컨테이너 클래스
 - 서블릿

### 메서드 사이에 존재하는 의존성을 조심하라
각 메서드에 synchronized 키워드로 락을 걸었지만, 메서드 사이의 의존성때문에 문제가 발생하는 경우이다.
해결방안으로는

#### 실패를 용인한다
한밤중에 시스템을 재부팅해 메모리 누수를 해결하는 방법과 비슷한 경우이다. 솔직히 말해 조잡하다.

#### 클라이언트 기반 잠금
각 클라이언트가 synchronized 키워드를 이용해서 락을 걸고, 메서드를 호출하는 경우이다.
클라이언트마다 이 행위를 반복하게 되므로 다소 위험한 방식이며 DRY를 위반한다.

#### 서버 기반 잠금
 - 코드 중복이 줄어든다
 - 성능이 좋아진다
 - 오류가 발생할 가능성이 적어진다
 - 스레드 정책이 하나이다
 - 공유 변수 범위가 줄어든다. (서버에 숨겨짐)

## 데드락
프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태이다.
다음 네 가지 조건을 모두 만족하면 데드락이 발생한다.

### 상호배제
 - 정의 : 여러 스레드가 동시에 사용하지 못하고, 개수가 제한적인 경우 ex) 데이터베이스 연결
 - 해결책
  - 동시에 사용해도 괜찮은 자원을 사용한다 ex) Atomic
  - 스레드 수 이상으로 자원 수를 늘린다
  - 자원을 점유하기 전에 필요한 자원이 모두 있는지 확인한다

### 잠금 & 대기
 - 정의 : 스레드가 자원을 점유하면 필요한 나머지 자원까지 모두 점유해 작업을 마칠 때까지 이미 점유한 자원을 내놓지 않는다.
 - 해결책
  - 대기하지 않기
 - 문제점
  - 기아(Starvation) : 한 스레드가 계속해서 필요한 자원을 점유하지 못하는 것
  - 라이브락(Livelock) : 여러 스레드가 한번에 잠금으로 들어가 계속 자원을 점유했다 내놨다를 반복하는 것

### 선점불가
 - 정의 : 한 스레드가 다른 스레드로부터 자원을 빼앗지 못함
 - 해결책 : 다른 스레드로부터 자원을 뺏어온다

### 순환대기
 - 정의 : 스레드 A는 B가 끝나기를 기다리고, 스레드 B는 A가 끝나기를 기다리는 상황
 - 해결책 : 모든 스레드가 동의하는 간단한 규약을 설정해서 순환이 없도록 한다
 - 문제점
  - 자원을 할당하는 순서와 자원을 사용하는 순서를 다르게 한다
  - 때로는 순서에 따라 자원을 할당하기 어렵다

## 다중 스레드 코드 테스트
 - 몬테 카를로 테스트 : 조율이 가능하게 유연하게 테스트를 만든다
 - 시스템을 배치할 플랫폼 전부에서 테스트를 돌린다
 - 부하가 변하는 장비에서 테스트를 돌린다.

## 스레드 코드 테스트를 도와주는 도구
대표적인 예시로 IBM의 ConTest가 있다.
 - 실제 코드와 테스트 코드 작성
 - ConTest로 실제 코드와 테스트 코드에 보조 코드 추가
 - 테스트를 실행
